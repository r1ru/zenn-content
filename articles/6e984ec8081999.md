---
title: "\"Hello World!\" on HinaOS"
emoji: "ğŸƒ"
type: "tech"
topics:
  - "è‡ªä½œos"
  - "ä½ãƒ¬ã‚¤ãƒ¤"
  - "ãƒã‚¤ã‚¯ãƒ­ã‚«ãƒ¼ãƒãƒ«"
  - "hinaos"
published: true
published_at: "2023-08-13 19:30"
---

# æ¦‚è¦
æœ€è¿‘ã€Œè‡ªä½œOSã§å­¦ã¶ãƒã‚¤ã‚¯ãƒ­ã‚«ãƒ¼ãƒãƒ«ã®è¨­è¨ˆã¨å®Ÿè£…ã€ã¨ã„ã†æœ¬ã‚’èª­ã‚“ã ã€‚ä»•çµ„ã¿ã‚’ã‚ˆã‚Šæ·±ãçŸ¥ã‚‹ãŸã‚ã«ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã“ã¨ã«ã—ãŸã€‚HinaOSã§ã€ŒHello World!ã€ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã¾ã§ã®éç¨‹ã‚’è¿½ã£ã¦ã¿ã‚‹ã€‚

https://amzn.asia/d/4aF8OJi

ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã«ã‚ã‚‹ã€‚
https://github.com/nuta/microkernel-book

# å®Ÿè¡Œ
![start-hello](https://storage.googleapis.com/zenn-user-upload/c6b4ec6ddd78-20230813.png)

# Code Reading
- ã¾ãšã¯shellã‚µãƒ¼ãƒãƒ¼ã®å‡¦ç†ã‚’è¿½ã†ã€‚
```c: servers/shell/main.c
void main(void) {
    char cmdline[1024];

    // startã‚³ãƒãƒ³ãƒ‰ã§èµ·å‹•ã—ãŸã‚¿ã‚¹ã‚¯ãŒçµ‚äº†ã—ãŸã‚‰çŸ¥ã‚‰ã›ã¦ã‚‚ã‚‰ã†ã‚ˆã†ã«ã—ã¦ãŠãã€‚
    struct message m;
    m.type = WATCH_TASKS_MSG;
    ASSERT_OK(ipc_call(VM_SERVER, &m));

    char *autorun = AUTORUN;
    if (autorun[0] != '\0') {
        strcpy_safe(cmdline, sizeof(cmdline), autorun);
        INFO("running autorun script: %s", cmdline);
        eval(cmdline);
    }

    // ä»–ã®ã‚µãƒ¼ãƒãŒèµ·å‹•ã—ã¦ã„ã‚‹ã¨ã‚·ã‚§ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒãƒ­ã‚°ã®ä¸­ã«ç´›ã‚Œã¦åˆ†ã‹ã‚Šã¥ã‚‰ã„ã®ã§ã€
    // ã“ã“ã§ã¡ã‚‡ã£ã¨å¾…ã¤ã€‚
    sys_time(100);
    ipc_recv(IPC_ANY, &m);
    ASSERT(m.type == NOTIFY_TIMER_MSG);

    printf("\nWelcome to HinaOS!\n\n");
    while (true) {
        printf("\x1b[1mshell> \x1b[0m");
        printf_flush();

        error_t err = read_line(cmdline, sizeof(cmdline));
        if (err == OK) {
            eval(cmdline);
        }
    }
}
```
- ipc_call(VM_SERVER, &m);ã®å‡¦ç†ã‚’è¿½ã†ã€‚dst, srcã‚’ã©ã¡ã‚‰ã‚‚VM_SERVERã«ã—ã¦ã€sys_ipcã‚’å‘¼ã‚“ã§ã„ã‚‹ã€‚ãƒ•ãƒ©ã‚°ã«ã¯IPC_CALLãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã€‚
```c: libs/user/ipc.c
error_t ipc_call(task_t dst, struct message *m) {
    error_t err = sys_ipc(dst, dst, m, IPC_CALL);
    if (err != OK) {
        return err;
    }

    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¿”ã£ã¦ãã‚Œã°ã€ãã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã€‚
    if (IS_ERROR(m->type)) {
        return m->type;
    }

    return OK;
```
- sys_ipcã¯arch_syscallã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã ã‘ã€‚arch_syscallã¯ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãƒ©ãƒƒãƒ‘ãƒ¼ã€‚
```c: libs/user/syscall.c
error_t sys_ipc(task_t dst, task_t src, struct message *m, unsigned flags) {
    return arch_syscall(dst, src, (uintptr_t) m, flags, 0, SYS_IPC);
}
```
```c: libs/user/riscv32/arch_syscall.h
static inline uint32_t arch_syscall(uint32_t r0, uint32_t r1, uint32_t r2,
                                    uint32_t r3, uint32_t r4, uint32_t r5) {
    register int32_t a0 __asm__("a0") = r0;  // a0ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t a1 __asm__("a1") = r1;  // a1ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t a2 __asm__("a2") = r2;  // a2ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t a3 __asm__("a3") = r3;  // a3ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t a4 __asm__("a4") = r4;  // a4ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t a5 __asm__("a5") = r5;  // a5ãƒ¬ã‚¸ã‚¹ã‚¿ã®å†…å®¹
    register int32_t result __asm__("a0");   // æˆ»ã‚Šå€¤ (a0ãƒ¬ã‚¸ã‚¹ã‚¿ã«æˆ»ã£ã¦ãã‚‹)

    // ecallå‘½ä»¤ã‚’å®Ÿè¡Œã—ã€ã‚«ãƒ¼ãƒãƒ«ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ© (riscv32_trap_handler) ã«å‡¦ç†ã‚’ç§»ã™ã€‚
    // è¿”ã‚Šå€¤ãŒa0ãƒ¬ã‚¸ã‚¹ã‚¿ (resultå¤‰æ•°) ã«æˆ»ã£ã¦ãã‚‹ã€‚
    __asm__ __volatile__("ecall"
                         : "=r"(result)
                         : "r"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5)
                         : "memory");
    return result;
}
```
- ãƒãƒ³ãƒ‰ãƒ©ã¯kernel/riscv32/handler.sã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’é€€é¿ã—ãŸä¸Šã§riscv32_handler_trapã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯kernel/riscv32/tarp.cã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
- ecallã‚’èª­ã‚“ã§ã„ã‚‹ã®ã§scauseã¯8(SCAUSE_ENV_CALL)ã«ãªã‚‹ã€‚ãã®ãŸã‚ã€ä»¥ä¸‹ã®å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚ãƒ­ãƒƒã‚¯ã‚’ã¨ã£ã¦handle_syscall_trapã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚
```c: kernel/riscv32/trap.c
        case SCAUSE_ENV_CALL:
            mp_lock();
            handle_syscall_trap(frame);
            mp_unlock();
            break;
```
- handle_syscall_trapã§ã¯handle_syscallã‚’å‘¼ã³å‡ºã—ã¦æˆ»ã‚Šå€¤ã‚’å–å¾—ã—ã¦ã„ã‚‹ã€‚
- handle_syscallã¯ãƒ•ãƒ©ã‚°ãŒSYS_IPCã®å ´åˆã¯sys_ipcã‚’å‘¼ã³å‡ºã™ã€‚åå‰ãŒåŒã˜ãªã®ãŒç´›ã‚‰ã‚ã—ã„ãŒã€ã“ã‚Œã¯ã•ã£ãã®sys_ipcã¨ã¯åˆ¥ç‰©ã€‚
```c: kernel/syscall.c
        case SYS_IPC:
            ret = sys_ipc(a0, a1, (__user struct message *) a2, a3);
            break;
```
- IPC_CALLã¯libs/common.h/message.hã§ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
- src, dstã¯å…±ã«VM_SERVERã ã£ãŸã€‚ä»¥ä¸‹ã§ã¯task_findã‚’å‘¼ã³å‡ºã—ã¦ã‚¿ã‚¹ã‚¯idãŒVM_SERVERã¨ãªã‚‹ã‚¿ã‚¹ã‚¯ã‚’æ¢ã—ã¦ã„ã‚‹ã€‚æœ€çµ‚çš„ã«ipcã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚
```c
#define IPC_CALL    (IPC_SEND | IPC_RECV)
```
```c: kernel/syscall.c
static error_t sys_ipc(task_t dst, task_t src, __user struct message *m,
                       unsigned flags) {
    // è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    if ((flags & ~(IPC_SEND | IPC_RECV | IPC_NOBLOCK)) != 0) {
        return ERR_INVALID_ARG;
    }

    // æœ‰åŠ¹ãªã‚¿ã‚¹ã‚¯IDã‹ãƒã‚§ãƒƒã‚¯
    if (src < 0 || src > NUM_TASKS_MAX) {
        return ERR_INVALID_ARG;
    }

    // é€ä¿¡å‡¦ç†ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€é€ä¿¡å…ˆã‚¿ã‚¹ã‚¯ã‚’å–å¾—
    struct task *dst_task = NULL;
    if (flags & IPC_SEND) {
        dst_task = task_find(dst);
        if (!dst_task) {
            return ERR_INVALID_TASK;
        }
    }

    return ipc(dst_task, src, m, flags);
}
```
- task_findã¯ã‚·ãƒ³ãƒ—ãƒ«ãªå®Ÿè£…ã«ãªã£ã¦ã„ã‚‹ã€‚tasksã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã€‚
```c: kernel/task.c
struct task *task_find(task_t tid) {
    if (tid < 0 || tid >= NUM_TASKS_MAX) {
        return NULL;
    }

    struct task *task = &tasks[tid - 1];
    if (task->state == TASK_UNUSED) {
        return NULL;
    }

    return task;
}
```
- ipcé–¢æ•°ã¯flagã«å¿œã˜ã¦é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚IPC_CALLã¯IPC_SENDã¨IPC_RECVã®orã ã£ãŸã®ã§ã€send_messaageã¨ã€recv_messageãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
```c: kernel/ipc.c
error_t ipc(struct task *dst, task_t src, __user struct message *m,
            unsigned flags) {
    // é€ä¿¡æ“ä½œ
    if (flags & IPC_SEND) {
        error_t err = send_message(dst, m, flags);
        if (err != OK) {
            return err;
        }
    }

    // å—ä¿¡æ“ä½œ
    if (flags & IPC_RECV) {
        error_t err = recv_message(src, m, flags);
        if (err != OK) {
            return err;
        }
    }

    return OK;
}
```
- ã¾ãšsend_messageã®å‡¦ç†ã‚’è¿½ã†ã€‚é•·ã„ã®ã§ã‚³ãƒ¼ãƒ‰ã¯çœç•¥ã€‚kernel/ipc.cã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
- æœ€åˆã«ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ãŒdstã«æŒ‡å®šã•ã‚Œã¦ã„ãªã„ã‹èª¿ã¹ã¦ã„ã‚‹ã‘ã©ã€currentã¯shellã‚µãƒ¼ãƒãƒ¼ã«ãªã‚‹ã®ã§å•é¡Œãªã„ã€‚
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ç©ºé–“ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ã¦ã€é€ä¿¡å…ˆãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¾…ã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ã„ã‚‹ã€‚vmã¯ãƒ•ãƒ©ã‚°ã«IPC_ANYã‚’æŒ‡å®šã—ã¦ipc_recvã‚’å‘¼ã‚“ã§ã„ã‚‹ã®ã§ã€ä»¥ä¸‹ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚
```c: kernel/ipc.c
memcpy(&dst->m, &copied_m, sizeof(struct message));
dst->m.src = (flags & IPC_KERNEL) ? FROM_KERNEL : current->tid;
task_resume(dst);
return OK;
```
- dst->mã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã„ã‚‹ã€‚dst->m.srcã¯current->tidã«ãªã‚‹ã®ã§ã€shellã‚µãƒ¼ãƒã®tidã«ãªã‚‹ã€‚
- task_resumeã®ä¸­ã§list_push_backã‚’å‘¼ã³å‡ºã—ã¦ãƒ©ãƒ³ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦ã„ã‚‹ã€‚ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆã¯è¡Œã£ã¦ã„ãªã„ã€‚
- ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆã¯ã‚¿ã‚¤ãƒãƒ¼å‰²ã‚Šè¾¼ã¿ã§è¡Œã£ã¦ã„ã‚‹ã€‚handler_timer_interruptãŒkernel/interrupt.cã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚å„ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’æ›´æ–°ã—ãŸå¾Œã«ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œæ™‚é–“ã‚’æ›´æ–°ã—ã¦0ã«ãªã£ãŸã‚‰task_switchã‚’å‘¼ã³å‡ºã—ã¦åˆ‡ã‚Šæ›¿ãˆã¦ã„ã‚‹ã€‚
- æ¬¡ã«recv_messageã®å‡¦ç†ã‚’è¿½ã†ã€‚é•·ã„ã®ã§ã‚³ãƒ¼ãƒ‰ã¯çœç•¥ã€‚kernel/ipc.cã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
- srcã¯VM_SERVERã ã£ãŸã®ã§ã€ä»¥ä¸‹ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚
- currentã¯shellã‚µãƒ¼ãƒã€‚wait_forã«VM_SERVERã‚’ä»£å…¥ã—ã¦ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã‚’ãƒ–ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã«(TASK_BLOCKED)ã«ã—ãŸã®ã¡ã€task_switchã§ã‚¿ã‚¹ã‚¯ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã„ã‚‹ã€‚task_switchã®ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã¨åˆ†ã‹ã‚‹ã®ã ãŒã€ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã¯ãƒ©ãƒ³ã‚­ãƒ¥ãƒ¼ã®ä¸­ã«ãªãã€ã‚¿ã‚¹ã‚¯ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹éš›ã«çŠ¶æ…‹ãŒTASK_RUNNABLEã®å ´åˆã«ã®ã¿ãƒ©ãƒ³ã‚­ãƒ¥ãƒ¼ã«æˆ»ã™å‡¦ç†ãŒã‚ã‚‹ã€‚ãã®ãŸã‚ã€ã“ã‚Œä»¥é™(vmã‚µãƒ¼ãƒã«ã‚ˆã£ã¦èµ·ã“ã•ã‚Œã‚‹ã¾ã§)shellã‚µãƒ¼ãƒãƒ¼ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
- vmã‚µãƒ¼ãƒãƒ¼ã«èµ·ã“ã•ã‚Œã‚‹ã¨ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’current->mã«ã‚³ãƒ”ãƒ¼ã—ã¦æˆ»ã‚‹ã€‚
```c: kernel/ipc.c
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã™ã‚‹ã¾ã§å¾…ã¤
        current->wait_for = src;
        task_block(current);
        task_switch();

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã£ãŸ
        current->wait_for = IPC_DENY;
        memcpy(&copied_m, &current->m, sizeof(struct message));
```
- æ¬¡ã«vmã‚µãƒ¼ãƒãƒ¼ã®å‡¦ç†ã‚’è¿½ã†ã€‚shellã‚µãƒ¼ãƒã‹ã‚‰é€ã‚‰ã‚Œã¦ãã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç¨®é¡ã¯WATCH_TASK_MSGã ã£ãŸã®ã§ã€ä»¥ä¸‹ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚
- shellã‚µãƒ¼ãƒã‚’è¦‹ã¤ã‘ã¦ã€watch_taskãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ãŸã®ã¡ã€ipc_replyã§å¿œç­”ã—ã¦ã„ã‚‹ã€‚
```c: servers/vm/main.c
            case WATCH_TASKS_MSG: {
                struct task *task = task_find(m.src);
                ASSERT(task);

                task->watch_tasks = true;

                m.type = WATCH_TASKS_REPLY_MSG;
                ipc_reply(m.src, &m);
                break;
```
- ipc_replyã¯ipc_send_noblockã‚’å‘¼ã³å‡ºã™ã ã‘ã€‚
```c: libs/user/ipc.c
void ipc_reply(task_t dst, struct message *m) {
    error_t err = ipc_send_noblock(dst, m);
    OOPS_OK(err);
}
```
- ipc_send_noblockã¯IPC_SENDã¨IPC_NOBLOCkãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘ã¦sys_ipcã‚’å‘¼ã³å‡ºã™ã€‚ä¸Šã§è¦‹ãŸå‡¦ç†ã®å¾Œã«ã€ipcãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
```c: libs/user/ipc.c
error_t ipc_send_noblock(task_t dst, struct message *m) {
    return sys_ipc(dst, 0, m, IPC_SEND | IPC_NOBLOCK);
}
```
- IPC_SENDãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã‚‹ã®ã§send_messageãŒå‘¼ã°ã‚Œã‚‹ã€‚shellã‚µãƒ¼ãƒãƒ¼ã¯recv_messageã‚’å‘¼ã³å‡ºã—ã¦TASK_BLOCKEDã«ãªã£ã¦ã„ãŸã®ã§ã€readyãŒtrueã«ãªã‚Šã€ä»¥ä¸‹ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚task_resumeã«ã‚ˆã‚Šã€shellã‚µãƒ¼ãƒãƒ¼ãŒå†ã³ãƒ©ãƒ³ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹ã€‚
```c: kernel/ipc.c
    memcpy(&dst->m, &copied_m, sizeof(struct message));
    dst->m.src = (flags & IPC_KERNEL) ? FROM_KERNEL : current->tid;
    task_resume(dst);
    return OK;
```
- shellã‚µãƒ¼ãƒãƒ¼ã®ç¶šãã‚’è¿½ã£ã¦ã„ãã€‚ã‚³ãƒ¼ãƒ‰ã‚’å†æ²ã™ã‚‹ã€‚
```c: servers/
    char *autorun = AUTORUN;
    if (autorun[0] != '\0') {
        strcpy_safe(cmdline, sizeof(cmdline), autorun);
        INFO("running autorun script: %s", cmdline);
        eval(cmdline);
    }

    // ä»–ã®ã‚µãƒ¼ãƒãŒèµ·å‹•ã—ã¦ã„ã‚‹ã¨ã‚·ã‚§ãƒ«ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒãƒ­ã‚°ã®ä¸­ã«ç´›ã‚Œã¦åˆ†ã‹ã‚Šã¥ã‚‰ã„ã®ã§ã€
    // ã“ã“ã§ã¡ã‚‡ã£ã¨å¾…ã¤ã€‚
    sys_time(100);
    ipc_recv(IPC_ANY, &m);
    ASSERT(m.type == NOTIFY_TIMER_MSG);

    printf("\nWelcome to HinaOS!\n\n");
    while (true) {
        printf("\x1b[1mshell> \x1b[0m");
        printf_flush();

        error_t err = read_line(cmdline, sizeof(cmdline));
        if (err == OK) {
            eval(cmdline);
        }
    }
}
```
- autorunã®å‡¦ç†ã¯è‰¯ãåˆ†ã‹ã‚‰ãªã„ã€‚ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã¿ãŸã„ãªæ„Ÿã˜ã‹ãªã€‚
- ãã®å¾Œsys_timeã‚’å‘¼ã³å‡ºã—ã¦ã€ä¸€å®šæ™‚é–“å¾…ã£ã¦ã„ã‚‹ã€‚ã‚¿ã‚¤ãƒãƒ¼å‰²ã‚Šè¾¼ã¿ã®ãƒãƒ³ãƒ‰ãƒ©å†…ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦é€šçŸ¥ã‚’é€ã‚‹å‡¦ç†ãŒã‚ã‚‹ã€‚
```c: kernel/interrupt.c
void handle_timer_interrupt(unsigned ticks) {
    // èµ·å‹•ã—ã¦ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’æ›´æ–°
    uptime_ticks += ticks;

    if (CPUVAR->id == 0) {
        // å„ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’æ›´æ–°ã™ã‚‹
        LIST_FOR_EACH (task, &active_tasks, struct task, next) {
            if (task->timeout > 0) {
                task->timeout -= MIN(task->timeout, ticks);
                if (!task->timeout) {
                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã®ã§ã‚¿ã‚¹ã‚¯ã«é€šçŸ¥ã™ã‚‹
                    notify(task, NOTIFY_TIMER);
                }
            }
        }
    }

    // å®Ÿè¡Œä¸­ã‚¿ã‚¹ã‚¯ã®æ®‹ã‚Šå®Ÿè¡Œå¯èƒ½æ™‚é–“ã‚’æ›´æ–°ã—ã€ã‚¼ãƒ­ã«ãªã£ãŸã‚‰ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆã‚’è¡Œã†
    struct task *current = CURRENT_TASK;
    DEBUG_ASSERT(current->quantum >= 0 || current == IDLE_TASK);
    current->quantum -= MIN(ticks, current->quantum);
    if (!current->quantum) {
        task_switch();
    }
}
```
- ãã®å¾Œç„¡é™ãƒ«ãƒ¼ãƒ—ã§ã‚³ãƒãƒ³ãƒ‰ã®èª­ã¿å–ã‚Šã¨å®Ÿè¡Œã‚’è¡Œã£ã¦ã„ã‚‹ã€‚"start hello"ãŒå…¥åŠ›ã•ã‚ŒãŸã¨ã—ã¦èª­ã¿é€²ã‚ã‚‹ã€‚
- å…¥åŠ›ã®è©•ä¾¡ã¯evalé–¢æ•°ã§è¡Œã£ã¦ã„ã‚‹ã€‚evalã¯å¼•æ•°ã¨å¼•æ•°ã®æ•°ã‚’struct argsã«å…¥ã‚Œã¦run_commandã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã€‚
- run_commadã®å®Ÿè£…ã¯é¢ç™½ã„ã€‚args->arg[0]ã¨cmd->nameã‚’æ¯”è¼ƒã—ã¦ã€ä¸€è‡´ã—ãŸå ´åˆã¯cmd->run(args)ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã€‚
```c: servers/shell/command.c
void run_command(struct args *args) {
    if (args->argc == 0) {
        return;
    }

    struct command *cmd = commands;
    while (cmd->name != NULL) {
        if (!strcmp(cmd->name, args->argv[0])) {
            cmd->run(args);
            return;
        }
        cmd++;
    }

    WARN("unknown command: %s", args->argv[0]);
}
```
commandsã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚ã‚ã‚‰ã‹ã˜ã‚é–¢æ•°ã¨åå‰ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€é•·ã„if-else, switch-caseã‚’é¿ã‘ã¦ã„ã‚‹ã€‚è¦‹ã‚„ã™ã„ã€‚
```c: servers/shell/command.c
static struct command commands[] = {
    {.name = "help", .run = do_help, .help = "Show this help"},
    {.name = "echo", .run = do_echo, .help = "Print arguments"},
    {.name = "http", .run = do_http, .help = "Fetch a URL"},
    {.name = "cat", .run = do_cat, .help = "Show file contents"},
    {.name = "write", .run = do_write, .help = "Write text to a file"},
    {.name = "ls", .run = do_listdir, .help = "List files in a directory"},
    {.name = "mkdir", .run = do_mkdir, .help = "Create a directory"},
    {.name = "delete", .run = do_delete, .help = "Delete a file or directory"},
    {.name = "start", .run = do_start, .help = "Launch a task from bootfs"},
    {.name = "sleep", .run = do_sleep, .help = "Pause for a while"},
    {.name = "ping", .run = do_ping, .help = "Send a ping to pong server"},
    {.name = "uptime", .run = do_uptime, .help = "Show seconds since boot"},
    {.name = "shutdown", .run = do_shutdown, .help = "Shut down the system"},
    {.name = NULL},
};
```
- "start hello"ã‚’å…¥åŠ›ã—ãŸå ´åˆã¯do_start(args)ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚
- do_startã®ä¸­ã§ã¯vmã«å¯¾ã—ã¦SPAWN_TASK_MSGã¨ã„ã†ã‚¿ã‚¤ãƒ—ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¦ã„ã‚‹ã€‚m.spawn_task.nameã¯"hello"ã«ãªã‚‹ã€‚
```c: servers/shell/commands.c
static void do_start(struct args *args) {
    if (args->argc != 2) {
        WARN("Usage: start <NAME>");
        return;
    }

    // ã‚¿ã‚¹ã‚¯ã‚’èµ·å‹•ã™ã‚‹
    struct message m;
    m.type = SPAWN_TASK_MSG;
    strcpy_safe(m.spawn_task.name, sizeof(m.spawn_task.name), args->argv[1]);
    error_t err = ipc_call(VM_SERVER, &m);
    if (IS_ERROR(err)) {
        WARN("failed to spawn %s: %s", args->argv[0], err2str(err));
    }
    
    [snip]
```
- SPAWN_TASK_MSGãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ã‚’è¿½ã†ã€‚
```c: servers/vm/main.c
            case SPAWN_TASK_MSG: {
                char name[sizeof(m.spawn_task.name)];
                strcpy_safe(name, sizeof(name), m.spawn_task.name);

                struct bootfs_file *file = bootfs_open(name);
                if (!file) {
                    ipc_reply_err(m.src, ERR_NOT_FOUND);
                    break;
                }

                task_t task_or_err = task_spawn(file);
                if (IS_ERROR(task_or_err)) {
                    ipc_reply_err(m.src, task_or_err);
                    break;
                }

                m.type = SPAWN_TASK_REPLY_MSG;
                m.spawn_task_reply.task = task_or_err;
                ipc_reply(m.src, &m);
                break;
            }
```
- bootfs_openã‚’å‘¼ã³å‡ºã—ã¦æŒ‡å®šã•ã‚ŒãŸåå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã—ã¦ã„ã‚‹ã€‚ã“ã“ã§ã¯"hello"ã«ãªã‚‹ã€‚
- ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã¯task_spawnã§ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã—ã¦ã€tidã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å…¥ã‚Œã¦å‘¼ã³å‡ºã—å…ƒã«æˆ»ã—ã¦ã„ã‚‹ã€‚
- task_spawnã¯servers/vm/task.cã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚elfãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã—ã¦ã„ã‚‹ã€‚sys_task_createã§ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚åŒåã®é–¢æ•°ãŒkernel/syscall.cã«ã‚ã‚‹ã€‚ãƒšãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¿ã‚¹ã‚¯ã¯vmã‚µãƒ¼ãƒãƒ¼ã«ãªã‚‹ã€‚ã“ã‚Œã§helloã‚µãƒ¼ãƒãƒ¼ãŒç”Ÿæˆã•ã‚Œã€ãƒ©ãƒ³ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹ã€‚
```c: kernel/syscall.c
static task_t sys_task_create(__user const char *name, uaddr_t ip,
                              task_t pager) {
    // ã‚¿ã‚¹ã‚¯åã‚’å–å¾—
    char namebuf[TASK_NAME_LEN];
    error_t err = strcpy_from_user(namebuf, sizeof(namebuf), name);
    if (err != OK) {
        return err;
    }

    // ãƒšãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
    struct task *pager_task = task_find(pager);
    if (!pager_task) {
        return ERR_INVALID_ARG;
    }

    // é€šå¸¸ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã™ã‚‹å ´åˆ
    return task_create(namebuf, ip, pager_task);
}
```
- helloã‚µãƒ¼ãƒãƒ¼ã¯printfã§"Hello World!"ã‚’è¡¨ç¤ºã—ã¦ã„ã‚‹ã ã‘ã€‚
```c: servers/hello/main.c
#include <libs/common/print.h>

void main(void) {
    INFO("Hello World!");
}
```
- shellã‚µãƒ¼ãƒãƒ¼ã®ç¶šãã‚’è¿½ã†ã€‚èµ·å‹•ã—ãŸhelloã‚µãƒ¼ãƒã®çµ‚äº†ã‚’å¾…ã£ã¦ã„ã‚‹ã€‚
```c: servers/shell/commands.c
    // ã‚¿ã‚¹ã‚¯ãŒçµ‚äº†ã™ã‚‹ã¾ã§å¾…ã¤
    task_t new_task = m.spawn_task_reply.task;
    while (true) {
        struct message m;
        ASSERT_OK(ipc_recv(IPC_ANY, &m));

        if (m.type == TASK_DESTROYED_MSG && m.task_destroyed.task == new_task) {
            break;
        }
    }
}
```
- helloã‚µãƒ¼ãƒã®çµ‚äº†ã®é€šçŸ¥ã¯task_exité–¢æ•°ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã€‚ã“ã‚ŒãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ãƒšãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¿ã‚¹ã‚¯(vmã‚µãƒ¼ãƒãƒ¼)ã«EXCEPTION_MSGãŒé£›ã³ã€task_destroyãŒå‘¼ã°ã‚Œã‚‹ã€‚ã“ã‚Œã§ã‚„ã£ã¨"start hello"ãŒçµ‚äº†ã™ã‚‹ã€‚
```c: kernel/task.c
__noreturn void task_exit(int exception) {
    struct task *pager = CURRENT_TASK->pager;
    ASSERT(pager != NULL);

    TRACE("exiting a task \"%s\" (tid=%d)", CURRENT_TASK->name,
          CURRENT_TASK->tid);

    // ãƒšãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¿ã‚¹ã‚¯ã«çµ‚äº†ç†ç”±ã‚’é€šçŸ¥ã™ã‚‹ã€‚ãƒšãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¿ã‚¹ã‚¯ãŒtask_destroyã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’
    // å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã“ã®ã‚¿ã‚¹ã‚¯ãŒå®Ÿéš›ã«å‰Šé™¤ã•ã‚Œã‚‹ã€‚
    struct message m;
    m.type = EXCEPTION_MSG;
    m.exception.task = CURRENT_TASK->tid;
    m.exception.reason = exception;
    error_t err = ipc(CURRENT_TASK->pager, IPC_DENY,
                      (__user struct message *) &m, IPC_SEND | IPC_KERNEL);

    if (err != OK) {
        WARN("%s: failed to send an exit message to '%s': %s",
             CURRENT_TASK->name, pager->name, err2str(err));
    }

    // ä»–ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã€‚ã‚‚ã†ã“ã®ã‚¿ã‚¹ã‚¯ã«æˆ»ã£ã¦ãã‚‹ã“ã¨ã¯ãªã„ã€‚
    task_block(CURRENT_TASK);
    task_switch();

    UNREACHABLE();
}
```
- å•é¡Œã¯task_exitãŒã©ã“ã‹ã‚‰å‘¼ã°ã‚Œã‚‹ã‹ã€‚æ€ªã—ã„ã®ã¯helloã‚µãƒ¼ãƒãƒ¼ãŒretå‘½ä»¤ã§æˆ»ã‚‹å…ˆã€‚ã¨ã„ã†ã“ã¨ã§ã€ã‚¿ã‚¹ã‚¯ç”Ÿæˆæ™‚ã®å‡¦ç†ã‚’è¿½ã†ã€‚task_createãŒå‘¼ã°ã‚Œã¦ã„ãŸã®ã§ã¾ãšã“ã‚Œã‚’è¦‹ã‚‹ã€‚
- task_createâ†’init_task_structâ†’arch_task_initã®é †ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚arch_task_initã‚’è¦‹ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªå‡¦ç†ãŒã‚ã‚‹ã€‚
```c: kernel/riscv32/task.c
    } else {
        // riscv32_user_entry_trampolineé–¢æ•°ã§ãƒãƒƒãƒ—ã•ã‚Œã‚‹å€¤
        *--sp = ip;  // ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œé–‹å§‹ã‚¢ãƒ‰ãƒ¬ã‚¹
        entry = (uint32_t) riscv32_user_entry_trampoline;
    }
```
-  riscv32_user_entry_trampolineã‹ã‚‰ã‚¿ã‚¹ã‚¯ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã«é£›ã¶ã£ã½ã„ã®ã§ã€ã“ã®é–¢æ•°ã‚’è¦‹ã‚‹ã€‚
```nasm: kernel/riscv32/switch.S
.align 4
.global riscv32_user_entry_trampoline
riscv32_user_entry_trampoline:
    // ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å¼•æ•°ã‚’å–ã‚Šå‡ºã—ã¦ã€riscv32_user_entryé–¢æ•°ã«ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹
    lw a0, 0 * 4(sp) // ip
    j riscv32_user_entry
```
-  riscv32_user_entryã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯kernel/riscv32/task.cã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚(é•·ã„ã®ã§çœç•¥)ã“ã“ã§ã¯ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‚¿ã‚¹ã‚¯ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã«é£›ã‚“ã§ã„ã‚‹ã€‚
- ã“ã®é–¢æ•°ã®æœ€å¾Œã«task_exitãŒã‚ã‚‹ã®ã‹ã¨æ€ã£ãŸãŒã€ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆã®é€šã‚Šã€ã“ã®é–¢æ•°ã«æˆ»ã£ã¦ãã‚‹ã“ã¨ã¯ãªã„ã‚‰ã—ã„ã€‚
```c: kernel/riscv32/task.c
    // ã“ã®é–¢æ•°ã«ã¯æ±ºã—ã¦æˆ»ã£ã¦ã“ãªã„ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã‚«ãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹ã¨ãã¯å¸¸ã«
    // riscv32_trap_handler ãŒå…¥ã‚Šå£ã¨ãªã‚‹ã€‚
    UNREACHABLE();
```
- å‘¼ã³å‡ºã—å…ƒã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã«ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ç·¨é›†ã—ãŸã€‚
```c: libs/user/syscall.c
// task_destroyã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«: ã‚¿ã‚¹ã‚¯ã®å‰Šé™¤
error_t sys_task_destroy(task_t task) {
    OOPS("sys_task_destroy");
    return arch_syscall(task, 0, 0, 0, 0, SYS_TASK_DESTROY);
}

// task_exitã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«: å®Ÿè¡Œä¸­ã‚¿ã‚¹ã‚¯ã®çµ‚äº†
__noreturn void sys_task_exit(void) {
    OOPS("sys_task_exit");
    arch_syscall(0, 0, 0, 0, 0, SYS_TASK_EXIT);
    UNREACHABLE();
}
```
- ã“ã®çŠ¶æ…‹ã§make runã—ã¦ã€"start hello"ã‚’å…¥åŠ›ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ãŸã€‚
![start-hello-debug](https://storage.googleapis.com/zenn-user-upload/1a0040affded-20230813.png)
- ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒåˆ†ã‹ã£ãŸã®ã§ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§elfãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‡ã‚£ã‚¹ã‚¢ã‚»ãƒ³ãƒ–ãƒªã—ã¦å ´æ‰€ã‚’ç‰¹å®šã™ã‚‹ã€‚
```bash
$ llvm-objdump -d -M intel ./build/servers/hello.elf.debug
```
- ã™ã‚‹ã¨ä»¥ä¸‹ã®ç®‡æ‰€ãŒãƒ’ãƒƒãƒˆã™ã‚‹ã€‚starté–¢æ•°ã‹ã‚‰mainé–¢æ•°ãŒå‘¼ã°ã‚ŒãŸå¾Œã€sys_task_exitãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã€‚ã¤ã¾ã‚Šhelloã‚µãƒ¼ãƒãƒ¼ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã¯mainé–¢æ•°ã§ã¯ãªãã€starté–¢æ•°ã€‚ã“ã‚Œã¯libs/user/riscv32/start.Sã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
```
240055c0 <start>:
240055c0: 01 44        	li	s0, 0

240055c2 <.Lpcrel_hi0>:
240055c2: 17 b1 48 00  	auipc	sp, 1163
240055c6: 13 01 e1 b4  	addi	sp, sp, -1202
240055ca: ef e0 2f ee  	jal	0x24003cac <hinaos_init>
240055ce: ef a0 3f a3  	jal	0x24000000 <main>
240055d2: ef d0 df 95  	jal	0x24002f2e <sys_task_exit>
240055d6: 00 00        	unimp	
```
```libs/user/riscv32/start.S
.align 4
.global start
start:
    mv fp, zero       // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¼ãƒ­ã«åˆæœŸåŒ–ã™ã‚‹ã“ã¨ã§ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒã“ã“ã§
                      // åœæ­¢ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
    la sp, __stack    // ã‚¹ã‚¿ãƒƒã‚¯ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šä½ã«è¨­å®šã™ã‚‹

    jal hinaos_init   // userãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆæœŸåŒ–
    jal main          // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ (mainé–¢æ•°)

    jal sys_task_exit // mainé–¢æ•°ã‹ã‚‰æˆ»ã£ã¦ããŸã‚‰ã‚¿ã‚¹ã‚¯ã‚’çµ‚äº†ã™ã‚‹
```
# åˆ†ã‹ã£ãŸã“ã¨
- microkernelã§ã¯"Hello World!"ã®è¡¨ç¤ºã ã‘ã§ã‚‚çµæ§‹è¤‡é›‘ãªå‡¦ç†ã«ãªã‚‹ã€‚
- kernelã«ã¯åŸºæœ¬çš„ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ç”¨ã®APIã ã‘ãŒã‚ã‚Šã€ã‚¿ã‚¹ã‚¯ã®ç”Ÿæˆã€å‰Šé™¤ã¨ã„ã£ãŸãƒ¢ãƒãƒªã‚·ãƒƒã‚¯ã‚«ãƒ¼ãƒãƒ«ã§ã¯æ™®é€škernelå†…ã«å®Ÿè£…ã•ã‚Œã‚‹å‡¦ç†ã‚’vmã‚µãƒ¼ãƒãƒ¼(ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ©ãƒ³ãƒ‰)ãŒè¡Œã£ã¦ã„ã‚‹ã€‚

# è€ƒå¯Ÿ
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°æ™‚ã«ã¯tidã‚’æŒ‡å®šã—ã¦ã„ãŸãŒã€ã€Œã©ã®ã‚µãƒ¼ãƒãƒ¼ãŒã©ã®tidã‚’æŒã¤ã‹ã€ã‚’çŸ¥ã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ãŒæ¬ ç‚¹ã ã¨æ€ã£ãŸã€‚ä»Šå›ã¿ãŸã„ã«å°‘æ•°ã®ã‚µãƒ¼ãƒãƒ¼ã—ã‹å‹•ã‹ã•ãªã„ãªã‚‰ã“ã‚Œã§ã‚‚å•é¡Œãªã„ã‘ã©ã€æ•°ãŒå¢—ãˆã‚‹ã¨ãã¤ããªã‚Šãã†ã€‚åå‰ã¨tidã‚’ç´ã¥ã‘ã‚‹ã€ã€Œåå‰è§£æ±ºã‚µãƒ¼ãƒãƒ¼ã€ãŒã‚ã‚‹ã¨ä¾¿åˆ©ã‹ã‚‚ã€‚
- ã‚¿ã‚¹ã‚¯åˆ‡ã‚Šæ›¿ãˆã¯å˜ç´”ãªãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ“ãƒ³ã§å®Ÿè£…ã•ã‚Œã¦ã„ãŸã‘ã©ã€ã€Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚µãƒ¼ãƒãƒ¼ã€ã‚’ä½œã‚Œã°ã„ã‚ã„ã‚ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¦é¢ç™½ãã†ã ã¨æ€ã£ãŸã€‚
- åŒæœŸçš„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ãŒæ¡ç”¨ã•ã‚Œã¦ã„ã¦ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒstruct taskã®ãƒ¡ãƒ³ãƒ(è¦ç´ æ•°1)ã«ãªã£ã¦ã„ãŸã€‚ä»Šå›ã®ã‚ˆã†ãªå˜ç´”ãªå‡¦ç†ã ã¨å¤§ä¸ˆå¤«ã ã‘ã©ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‘¨ã‚Šã®å‡¦ç†ã¨ã‹ã€ãŸãã•ã‚“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚„ã‚Šå–ã‚Šã—ãã†ãªã®ã§ã€ã“ã®å®Ÿè£…ã ã¨è¾›ãã†ã ãªã¨æ€ã£ãŸã€‚(å¾Œã§å®Ÿè£…èª­ã‚€)ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«ã—ã¦ã€éåŒæœŸã§ã‚„ã‚Šå–ã‚Šã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã¨æ€ã£ãŸã€‚